---
title: "Calculating Area Under the Concentration-Response Curve with tcplfit2"
author: "Center for Computational Toxicology and Exposure"
output:
   prettydoc::html_pretty:
    theme: architect
    toc: yes
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Calculating_AUC_with_tcplfit2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, warning=FALSE, echo=FALSE}
library(tcplfit2)
```

# Introduction

This vignette will walk you through how to obtain area under the curve (AUC) for concentration-response curves with `tcplfit2` in various applications. AUC can be think of a measure of overall efficacy/potency that users may want to include as part of their analyses. 

# Main Feature 

`concRespCore` function has a logical argument `AUC` that controls whether or not area under the curve (AUC) value for the winning model is obtained and returned alongside with the model and hit-calling details. This argument defaults to `TRUE` to always include AUC in the output, but one can exclude it by setting it to `FALSE`.
```{r example 1}
# some example data
conc <- list(.03, .1, .3, 1, 3, 10, 30, 100)
resp <- list(0, .2, .1, .4, .7, .9, .6, 1.2)
row <- list(conc = conc,
            resp = resp,
            bmed = 0,
            cutoff = 1,
            onesd = .5)

# AUC is included in the output
concRespCore(row, conthits = TRUE)
```

The following sections demonstrate how one can obtain AUC when they do curve fitting and hit-calling separately with `tcplfit2_core` and `tcplhit2_core`, and what AUC means for different types of curves. 

# Applications
## Positive Curves
This section provides an example of how to use `get_AUC` function in `tcplfit2` to calculate area under the curves (AUC) for a given concentration-response curve. First, use codes below to fit some curves with a few example data. 
```{r example 2, fig.height = 4.55, fig.width = 8}
# This is taken from the example under tcplfit2_core
conc_ex2 <- c(.03, .1, .3, 1, 3, 10, 30, 100)
resp_ex2 <- c(0, .1, 0, .2, .6, .9, 1.1, 1)

# fit all available models in the package
# use do.plot = TRUE to show all fitted curves 
oldpar <- par(no.readonly = TRUE)
on.exit(par(oldpar))   
par(xpd = TRUE)
output_ex2 <- tcplfit2_core(conc_ex2, resp_ex2, .8, do.plot = TRUE)
```

**Figure 1:** This figure depicts all concentration-response curves fitted. The models are polynomial 1 and 2, power, hill, gain-loss, exponential 2 to exponential 5. 

We can use the `get_AUC` function to calculate AUC for a single model. Inputs to this function are: the name of the model, lower and upper concentration bounds (usually are the lowest and the highest concentration in the data), and fitted model parameters. Codes below demonstrate how to calculate AUC for the hill model, starting by showing how to extract information from the output of `tcplfit2_core` and input them into the `get_AUC` function. After calculated the AUC, plot the hill curve and shade the area below the curve to see if the returned value makes sense. 
```{r example 2 cont., fig.height = 6, fig.width = 6}
fit_method <- "hill"
# extract the parameters 
modpars <- output_ex2[[fit_method]][output_ex2[[fit_method]]$pars]

# plug into get_AUC function 
# for hill and gnls, no need to convert concentration used for bounds to log-scale 
# they will be converted inside the function
get_AUC(fit_method, min(conc_ex2), max(conc_ex2), modpars)

# extract the predicted responses from the model
pred_resp <- output_ex2[[fit_method]][["modl"]]

# plot to see if the result make sense
# the shaded area is what the function tries to find
plot(log10(conc_ex2), pred_resp)
lines(log10(conc_ex2), pred_resp)
polygon(c(log10(conc_ex2), max(log10(conc_ex2))), c(pred_resp, min(pred_resp)), col=rgb(1, 0, 0,0.5))
```

**Figure 2:** The red region is the area under the fitted hill curve. AUC calculated by the `get_AUC` function is 1.64823. It seems to be a good estimate for the area of the shaded region. 

We can calculate AUC for other models too (excluding constant model).
```{r example 2 other models}
# hill and gnls will return a much smaller number because they are in log10-scale 
fitmodels = c("gnls", "poly1", "poly2", "pow", "exp2", "exp3", "exp4", "exp5")
mylist <- list()
for (model in fitmodels){

  fit_method <- model
  # extract corresponding model parameters
  modpars <- output_ex2[[fit_method]][output_ex2[[fit_method]]$pars]
  
  # get AUC
  mylist[[fit_method]] <- get_AUC(fit_method, min(conc_ex2), max(conc_ex2), modpars)
  
}
# print AUC's for other models 
data.frame(mylist,row.names = "AUC")
```

## Negative curves

This session will examine how `get_AUC` function behave with negative curves. Taking some example data for negative curves from example 3 in the [tcplfit2 vignette](tcplfit2_vignette.html). 
```{r example 3, fig.height = 4.55, fig.width = 8}
# Taking the code from example 3 in the vignette 
library(stringr)  # string management package
data("signatures")

# use row 5 in the data
conc=as.numeric(str_split(signatures[5,"conc"],"\\|")[[1]])
resp=as.numeric(str_split(signatures[5,"resp"],"\\|")[[1]])
cutoff=signatures[5,"cutoff"]

# plot all models, this is an example of negative curves 
oldpar <- par(no.readonly = TRUE)
on.exit(par(oldpar))   
par(xpd = TRUE)
output_negative <- tcplfit2_core(conc, resp, cutoff, do.plot = TRUE)
```

**Figure 3:** This plot depicts all fitted concentration-response curves. All curves are decreasing from 0 and are below x-axis. 

For example, we try to calculate AUC for exponential 3 model with the `get_AUC` function. We've noticed that the function returns a negative AUC, -12.92738.    
```{r example 3 cont., fig.height = 6, fig.width = 6}
fit_method <- "exp3"

# extract corresponding model parameters and predicted response
modpars <- output_negative[[fit_method]][output_negative[[fit_method]]$pars]
pred_resp <- output_negative[[fit_method]][["modl"]]

get_AUC(fit_method, min(conc), max(conc), modpars)

# plot this curve
pred_resp <- pred_resp[order(conc)]
plot(conc[order(conc)], pred_resp)
lines(conc[order(conc)], pred_resp)
polygon(c(conc[order(conc)], max(conc)), c(pred_resp, max(pred_resp)), col=rgb(1, 0, 0,0.5))
```

**Figure 4:** Note that the x-axis in this plot is in regular unit, so it looks different from the curve in figure 3, whose x-axis is in log-10 scale. The absolute value 12.92738 seems to be a good estimate for the area between the curve and x-axis. 

When integrating over a negative curve, the function will return a negative AUC value. However, some users may want to consider all "areas" positive. In this case, they can use `return.abs = TRUE` argument in `get_AUC` to convert negative AUC to positive when return. This argument is defaulted to `FALSE`. 
```{r example 3 convert negative AUC}
get_AUC(fit_method, min(conc), max(conc), modpars, return.abs = TRUE) 
```

## Bi-phasic Curves

For now, none of the models in `tcplfit2` package would be able to fit a bi-phasic curve. This session for demonstration purpose shows what happens if one wanted to calculate AUC for a bi-phasic curve.  

The following chunk simulates a polynomial 2 curve that has areas below and above x-axis. Please note that polynomial 2 implemented in this package is re-parameterized so that it assumes the baseline response is always 0. 

Polynomial 2 in this package is implemented as $a*(\frac{x}{b} + \frac{x^2}{b^2})$. Use a = 1 and b = -2 to simulate a curve of $\frac{1}{4} x^2 - \frac{1}{2}x$
```{r example 4, fig.height = 6, fig.width = 6}
# simulate a poly2 curve
ps <- unlist(list(a = 1, b = -2))
conc_sim <- c(0, 0.03, 0.10, 0.30, 1.00, 2.00, 2.50, 3.00, 3.20)
resp_sim <- poly2(ps, conc_sim)

# plot the curve 
plot(conc_sim, resp_sim)
lines(conc_sim, resp_sim)
abline(h = 0)
polygon(conc_sim[1:6], resp_sim[1:6], col=rgb(1, 0, 0,0.5))
polygon(c(conc_sim[6:9], 3.20), c(resp_sim[6:9], 0), col=rgb(0, 1, 0,0.5))
```

**Figure 5:** This plot depicts the simulated polynomial curve. This curve decreases first and then increases, crosses the x-axis at `x = 2`. 

```{r, example 4 cont.}
# get AUC for the simulated Polynomial 2 curve 
get_AUC("poly2", min(conc_sim), max(conc_sim), ps)
```

If we integrate over a curve that has areas below and above the x-axis, the function will return the difference between the total area above the x-axis and the total area blow x-axis (green region minus red region). In this example, area above the x-axis is slightly larger than the area below the x-axis so the function returned a positive difference.   

AUC is used as an indicator of overall effect size, so for curves that pass the x-axis, it makes more sense to report the total area of the sections above and below x-axis (i.e., green region plus red region). To do that, we need to calculate the area sections separately and sum them together. Codes below demonstrate how to do that for the simulated polynomial 2 curve. One would need to identify where the curve intercepts with x-axis in order to calculate area sections separately. In this example, we know the x-intercept is at `x = 2`.   
```{r, example 4 cont.2}
# calculate area of each section separately and then sum them together 
x_intercept <- 2
abs(get_AUC("poly2", min(conc_sim), x_intercept, ps)) + get_AUC("poly2", x_intercept, max(conc_sim), ps)
```
The total area of red region plus green region is 0.8373333. 

# AUC after hit-calling

In some cases, users might want to run `tcplfit2_core` and `tcplhit2_core` separately, and only want to obtain AUC for the winning model selected in `tcplhit2_core`. 

Output from `tcplhit2_core` is in form of a one-row data frame that contains concentration data, winning model name and the fitted parameter values. Codes below provide an example of how to use the wrapper function `post_hit_AUC` for `get_AUC`. This wrapper function is able to extract information from one-row data frame output and pass them into `get_AUC` to calculate AUC. One don't need to manually enter the model name, parameters values, etc. into `get_AUC`.  

The winning model from the positive curve example is the Hill model. Compare the AUC from above, 1.64823, with the AUC returned from the `post_hit_AUC` function. They should be identical.
```{r example 5}
out <- tcplhit2_core(output_ex2, conc_ex2, resp_ex2, 0.8, onesd = 0.4)
out
post_hit_AUC(out)
```







