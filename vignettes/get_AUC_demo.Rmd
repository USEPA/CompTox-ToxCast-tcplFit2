---
title: "Calculating the Area Under the Concentration-Response Curve with tcplfit2"
author: "Center for Computational Toxicology and Exposure"
output:
   prettydoc::html_pretty:
    theme: architect
    toc: yes
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Calculating_AUC_with_tcplfit2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, warning=FALSE, echo=FALSE}
## Main package
library(tcplfit2)
## Plotting packages
library(ggplot2)
library(gridExtra)
```

# Introduction

This vignette walks through how to estimate the area under the curve (AUC) for concentration-response curves with `tcplfit2`, with various applications. The AUC can be interpreted as a measure of overall efficacy/potency, which users may want to include as part of their analyses.

# Main Feature 

The `concRespCore` function has a logical argument `AUC` controlling whether the area under the curve (AUC) is calculated for the winning model and returned alongside the other modeling results (e.g. model parameters and hit-call details). This argument defaults to `FALSE`, such that the AUC will only be included in the output when the users requested it (i.e. `AUC=TRUE`).

```{r example 1}
# some example data
conc <- list(.03, .1, .3, 1, 3, 10, 30, 100)
resp <- list(0, .2, .1, .4, .7, .9, .6, 1.2)
row <- list(conc = conc,
            resp = resp,
            bmed = 0,
            cutoff = 1,
            onesd = .5)

# AUC is included in the output
concRespCore(row, conthits = TRUE, AUC = TRUE)
```

The following sections demonstrate how to estimate the AUC when curve fitting is performed with `concRespCore` as well as separate calls to `tcplfit2_core` and `tcplhit2_core`.  Additionally, we provide several types of potential curve fits with the resulting AUC and how to interpret it. 

# Applications

## Positive Curves {#positivecurve}

This section provides an example of how to use `get_AUC` function in `tcplfit2` to calculate area under the curves (AUC) for a given concentration-response curve. First, we need some curves obtained from curve-fitting on with a few data examples. 

```{r example 2, fig.height = 4.55, fig.width = 8}
# This is taken from the example under tcplfit2_core
conc_ex2 <- c(.03, .1, .3, 1, 3, 10, 30, 100)
resp_ex2 <- c(0, .1, 0, .2, .6, .9, 1.1, 1)

# fit all available models in the package
# show all fitted curves 
output_ex2 <- tcplfit2_core(conc_ex2, resp_ex2, .8)
grid.arrange(plot_allcurves(output_ex2, conc_ex2, resp_ex2),
          plot_allcurves(output_ex2, conc_ex2, resp_ex2, log_conc = TRUE), ncol = 2)
```

**Figure 1:** This figure depicts all fitted concentration-response curves for some example data, with concentrations in normal units (left) and in $log_{10}$ units (right).

We can use the `get_AUC` function to calculate the AUC for a single model. Inputs to this function are: the name of the model, lower and upper concentration bounds (usually the lowest and the highest concentrations in the data, respectively), and the estimated model parameters. The code chunk below demonstrate how to calculate AUC for the hill model, starting with extracting the fitted model parameters from `tcplfit2_core` output then inputting these information into the `get_AUC` function. After estimating the AUC, we plot the hill curve and shade the corresponding area under the curve.

```{r example 2 cont., fig.height = 6, fig.width = 6}
fit_method <- "hill"
# extract the parameters 
modpars <- output_ex2[[fit_method]][output_ex2[[fit_method]]$pars]

# plug into get_AUC function 
estimated_auc1 <- get_AUC(fit_method, min(conc_ex2), max(conc_ex2), modpars)
estimated_auc1

# extract the predicted responses from the model
pred_resp <- output_ex2[[fit_method]][["modl"]]

# plot to see if the result make sense
# the shaded area is what the function tries to find
plot(conc_ex2, pred_resp)
lines(conc_ex2, pred_resp)
polygon(c(conc_ex2, max(conc_ex2)), c(pred_resp, min(pred_resp)), col=rgb(1, 0, 0,0.5))
```

**Figure 2:** The red region is the area under the fitted hill curve. The AUC estimated with `get_AUC` is `r round(estimated_auc1,5)`. This estimate seems to align with the area of the shaded region. 

We can also calculate the AUC for other models too (with exception of the constant model).

```{r example 2 other models}
# list of models
fitmodels = c("gnls", "poly1", "poly2", "pow", "exp2", "exp3", "exp4", "exp5")
mylist <- list()
for (model in fitmodels){

  fit_method <- model
  # extract corresponding model parameters
  modpars <- output_ex2[[fit_method]][output_ex2[[fit_method]]$pars]
  
  # get AUC
  mylist[[fit_method]] <- get_AUC(fit_method, min(conc_ex2), max(conc_ex2), modpars)
  
}
# print AUC's for other models 
data.frame(mylist,row.names = "AUC")
```

As shown in Figure 1, the fitted curves are sometimes visualized with concentrations in the $log_{10}$ units. AUC can be estimated in the same way too. With argument `use_log = TRUE`, the function will return AUC calculated with concentrations in the $log_{10}$ units. A warning would be printed when this option is used.

```{r example 2 AUC log}
# list of models
fitmodels = c("gnls", "hill", "poly1", "poly2", "pow", "exp2", "exp3", "exp4", "exp5")
mylist <- list()
for (model in fitmodels){

  fit_method <- model
  # extract corresponding model parameters
  modpars <- output_ex2[[fit_method]][output_ex2[[fit_method]]$pars]
  
  # get AUC with log10 concentrations
  # the lower and upper bounds are not needed to be in log10 scale
  # conversion occurs inside the function
  mylist[[fit_method]] <- get_AUC(fit_method, min(conc_ex2), max(conc_ex2), modpars, 
                                  use.log = TRUE)
  
}
# print AUC's for other models 
data.frame(mylist,row.names = "AUC")
```


## Negative curves

This section demonstrates the behavior of the `get_AUC` function with negative curves. Here, we use some example data from example 3 in the [tcplfit2 vignette](https://cran.r-project.org/web/packages/tcplfit2/vignettes/tcplfit2-vignette.html). 

```{r example 3, fig.height = 4.55, fig.width = 8}
# Taking the code from example 3 in the vignette 
library(stringr)  # string management package
data("signatures")

# use row 5 in the data
conc=as.numeric(str_split(signatures[5,"conc"],"\\|")[[1]])
resp=as.numeric(str_split(signatures[5,"resp"],"\\|")[[1]])
cutoff=signatures[5,"cutoff"]

# plot all models, this is an example of negative curves 
output_negative <- tcplfit2_core(conc, resp, cutoff)
grid.arrange(plot_allcurves(output_negative, conc, resp),
          plot_allcurves(output_negative, conc, resp, log_conc = TRUE), ncol = 2)
```

**Figure 3:** This plot depicts all fitted concentration-response curves for an example from the `signatures` dataset. All curves are decreasing starting from 0 and are below x-axis. 

The code chunk below calculates the AUC for the exponential 3 model with the `get_AUC` function. 

```{r example 3 cont., fig.height = 6, fig.width = 6}
fit_method <- "exp3"

# extract corresponding model parameters and predicted response
modpars <- output_negative[[fit_method]][output_negative[[fit_method]]$pars]
pred_resp <- output_negative[[fit_method]][["modl"]]

estimated_auc2 <- get_AUC(fit_method, min(conc), max(conc), modpars)
estimated_auc2

# plot this curve
pred_resp <- pred_resp[order(conc)]
plot(conc[order(conc)], pred_resp)
lines(conc[order(conc)], pred_resp)
polygon(c(conc[order(conc)], max(conc)), c(pred_resp, max(pred_resp)), col=rgb(1, 0, 0,0.5))
```

**Figure 4:** Notice the function returns a negative AUC value, `r round(estimated_auc2, 5)`. The absolute value, `r abs(round(estimated_auc2,5))`, seems to align with the area between the curve and x-axis.

As demonstrated, when integrating over a curve in the negative direction, the function will return a negative AUC value. However, some users may want to consider all "areas" as positive values. For this reason, we added the `return.abs = TRUE` argument in `get_AUC` to convert negative AUC values to positive values when returned. This argument is by default `FALSE`.

```{r example 3 convert negative AUC}
get_AUC(fit_method, min(conc), max(conc), modpars, return.abs = TRUE) 
```

## Bi-phasic Curves

Polynomial 2 model in `tcplfit2` is capable of fitting bi-phasic curves. This section demonstrates what happens if the user want to estimate the AUC for a bi-phasic curve.  

The following chunk simulates a polynomial 2 curve that has area below and above the x-axis. Please note, the polynomial 2 model implemented in this package is re-parameterized such that the baseline response is always assumed to be 0. 

```{r example 4, fig.height = 6, fig.width = 6}
# simulate a poly2 curve
conc_sim <- seq(0,3, length.out = 100)
## biphasic poly2 parameters
b1 <- -1.3
b2 <- 0.7
## converted to tcplfit2's poly2 parameters
a <- b1^2/b2
b <- b1/b2

## plot the curve
resp_sim <- poly2(c(a, b, 0.1), conc_sim)
plot(conc_sim, resp_sim)
abline(h = 0)
```

**Figure 5:** This plot illustrates the simulated bi-phasic polynomial 2 curve. The curve initially decreases, then increases and crosses the x-axis at around `x = 1.857` (x-intercept). 

```{r, example 4 cont.}
# get AUC for the simulated Polynomial 2 curve 
get_AUC("poly2", min(conc_sim), max(conc_sim), ps = c(a, b))
```

Integrating over a curve with area above and below the x-axis, the current function returns the difference between the total area above the x-axis and the total area below the x-axis (i.e. blue region minus red region). In this example, area above the x-axis is slightly larger than the area below the x-axis so the function returned a positive difference.   

Since the AUC is used as an indicator of overall effect size in a toxicological context, then it makes more sense to report the total area of the above and below x-axis (i.e., blue region plus red region) for bi-phasic curves. To do that, we need to calculate each area separately and take the sum of those areas. The code below demonstrate how this is done for the previously simulated polynomial 2 curve. It should be noted, one needs to identify where the x-intercept(s) occur in order to calculate each area. In this example, the non-zero x-intercept is at x = `r round((-b1-b1)/(2*b2), 3)`. 

```{r, example 4 cont.2}
# calculate area of each section separately and then sum them together 
x_intercept <- 1.857
total_auc <- abs(get_AUC("poly2", min(conc_sim), x_intercept, ps = c(a, b))) + 
  get_AUC("poly2", x_intercept, max(conc_sim), ps = c(a, b))
total_auc
```

The total area of red region plus blue region is `r total_auc`. 

# AUC after hit-calling

In some cases, users may want to run the `tcplfit2_core` and `tcplhit2_core` functions separately, and only obtain the AUC for the winning model from `tcplhit2_core`. Thus, `tcplfit2` also includes a wrapper function for `get_AUC`, called `post_hit_AUC`, which allows users to estimate the AUC for the winning model only.

`tcplhit2_core` provides output in a data frame format with a single row containing the concentration-response data, the winning model name along with the fitted parameter values, and hit-calling results. The code chunk below provides an example demonstrating how to use the wrapper function `post_hit_AUC`. Internally, the wrapper function extracts information from the one-row data frame output and pass it to `get_AUC`, which calculates the AUC. Thus, manual entry of the model name, parameters values, etc. into `get_AUC` is not necessary with `post_hit_AUC`.

The winning model from the [positive curve example](#positivecurve) is the Hill model. Comparing the AUC from the previous example and the AUC returned from the `post_hit_AUC` here should be identical, i.e. `r round(estimated_auc1,5)`.

```{r example 5}
out <- tcplhit2_core(output_ex2, conc_ex2, resp_ex2, 0.8, onesd = 0.4)
out
post_hit_AUC(out)
```







