---
title: "get_AUC Demonstration and Test Codes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{get_AUC_Demonstration_and_Test_Codes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, warning=FALSE, echo=FALSE}
library(tcplfit2)
source("../R/get_AUC.R")
```

# Demonstration

```{r example 1, fig.height = 6, fig.width = 6}
# This is taken from the example under tcplfit2_core
conc <- c(.03, .1, .3, 1, 3, 10, 30, 100)
resp <- c(0, .1, 0, .2, .6, .9, 1.1, 1)

# use verbose to show the winning model and plot all models 
output <- tcplfit2_core(conc, resp, .8, verbose = TRUE, do.plot = TRUE)
```

Let say we want to get AUC for the winning model, in this case, hill. We can do that with get_AUC() with inputs: the name of the model, lower and upper bounds (of the area), and estimated model parameters. In the following codes I will use the function and then plot to check if the result make sense.

```{r example 1 cont., fig.height = 6, fig.width = 6}
fit_method <- "hill"
# extract the parameters 
modpars <- output[[fit_method]][output[[fit_method]]$pars]
# extract the predicted responses from the model
pred_resp <- output[[fit_method]][["modl"]]

# plug in the function 
# for hill and gnls, no need to convert conc to log-scale it will do so inside the function
get_AUC(fit_method, min(conc), max(conc), modpars)

# plot to see if the result make sense
# the shaped area is what the function tries to find
plot(log10(conc), pred_resp)
lines(log10(conc), pred_resp)
polygon(c(log10(conc), max(log10(conc))), c(pred_resp, min(pred_resp)), col="yellow")
```

We can do the same for other models too (excluding constant model).

```{r example 1 other models}
fitmodels = c("poly1", "poly2", "pow", "exp2", "exp3", "exp4", "exp5")

for (model in fitmodels){

  fit_method <- model
  # extract corresponding model parameters
  # these results for all model fitted are available in the result from tcplfit2_core  
  modpars <- output[[fit_method]][output[[fit_method]]$pars]

  # predicted response can also be extract from results
  pred_resp <- output[[fit_method]][["modl"]]
  
  # get AUC
  print(get_AUC(fit_method, min(conc), max(conc), modpars))
  
  #plot(conc, pred_resp)
  #lines(conc, pred_resp)
  #polygon(c(conc, max(conc)),c(pred_resp, min(pred_resp)), col="yellow")

}
```

# Examine how this function behave with negative curves

Taking example 3 from the vignette which gives data for negative curves and curves that have area both above and below 0.

```{r example 2, fig.height = 6, fig.width = 6}
# Taking the code from example 3 in the vignette 
library(stringr)  # string management package
data("signatures")

# use row 5 in the data
conc=as.numeric(str_split(signatures[5,"conc"],"\\|")[[1]])
resp=as.numeric(str_split(signatures[5,"resp"],"\\|")[[1]])
cutoff=signatures[5,"cutoff"]

# plot all models, this is an example of negative curves 
output_negative <- tcplfit2_core(conc, resp, cutoff, do.plot = TRUE)
    
```

Take one of the model to check - exp3

```{r example 2 cont., fig.height = 6, fig.width = 6}
fit_method <- "exp3"

# extract corresponding model parameters and predicted response
modpars <- output_negative[[fit_method]][output_negative[[fit_method]]$pars]
pred_resp <- output_negative[[fit_method]][["modl"]]


get_AUC(fit_method, min(conc), max(conc), modpars) # returns -12.92

# plot this curve
pred_resp <- pred_resp[order(conc)]
plot(conc[order(conc)], pred_resp)
lines(conc[order(conc)], pred_resp)
polygon(c(conc[order(conc)], max(conc)), c(pred_resp, max(pred_resp)), col="yellow")
```


Things to consider: The x-axis in plot above is in regular unit so it looks different from the figure above which uses log-conc for x-axis. The absolute value 12.92 seems to be a legit estimate for the area above the curve (technically can't call it AUC anymore), but it's returned as a negative number. Need more consideration of how to work with sign. 

Then use another example to check what happen if a curve have areas both below and above x-axis.

```{r example 3, fig.height = 6, fig.width = 6}
# simulate a poly2 curve
ps <- unlist(list(a = 1, b = -2))
conc_sim <- c(0, 0.03, 0.10, 0.30, 1.00, 2.00, 2.50, 3.00, 3.20)
resp_sim <- poly2(ps, conc_sim)

# plot the curve 
plot(conc_sim, resp_sim)
lines(conc_sim, resp_sim)
abline(h = 0)
polygon(conc_sim[1:6], resp_sim[1:6], col="yellow")
polygon(c(conc_sim[6:9], 3.20), c(resp_sim[6:9], 0), col="blue")
```

```{r, example 3 cont.}
get_AUC("poly2", min(conc_sim), max(conc_sim), ps)
```

If we integrate over a curve that has areas below and above 0, the function will return area above the curve minus area blow the curve (blue-yellow). In this example, area above the curve for the simulated curve is slightly larger than the area below the curve so it returns a positive value. The function seems to function normally but this might not be how the biologist/toxicologist want to interpret and use it. Further consideration needed. 


# Compare results

Compare the result of my function to the result from Katie's code

```{r compare results-gnls}
conc <- c(.03, .1, .3, 1, 3, 10, 30, 100)

# Katie's code 
gnls_curve <- function(top, ga, gw, la, lw, lconc){
    gain <- 1/(1+10^((ga - lconc)*gw))
    loss <- 1/(1+10^((lconc - la)*lw))
    return(top*gain*loss)
}

mapply(function(lower,
upper,
top,
ga,
gw,
la,
lw) integrate(gnls_curve,
lower,
upper,
top=top,
ga=ga,
gw=gw,
la=la,
lw=lw)$value,
lower = min(log10(conc)),
upper = max(log10(conc)),
top = 1.023238,
ga = log10(2.453007),
gw = 1.592714,
la = log10(4288.993065),
lw = 5.770323)

# my function 
ps <- list(tp = 1.023238, ga = 2.453007, p = 1.592714, la = 4288.993065,
           q = 5.770323, er = -3.295309 )
get_AUC("gnls", min(conc), max(conc), ps)
```


