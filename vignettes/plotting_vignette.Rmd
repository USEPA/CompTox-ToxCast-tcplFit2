---
title: "Plotting Vignette"
output: html_document
date: "2024-01-17"
---

```{r setup, packages, warning=FALSE, message=FALSE}
library(tcplfit2)
library(dplyr)
library(stringr)
library(ggplot2)
library(gridExtra)
devtools::load_all()
```

# Introduction
This plotting vignette shows you two functions in `tcplfit2` package. The first function `plot_allcurves` takes in output from `tcplfit2_core` and plots the concentration response data along with all the model fits. The second function `concRespPlot2` takes in output from `tcplhit2_core` or `concRespCore` and generates a basic plot of the winning model. The returned plots are ggplot objects and are capable of being customized to have additional details to the plot, such as markings for cutoff, BMR, BMD, BMD CI, other curve fits, etc. with `ggplot2` add-on. This will be demonstrated in the vignette as well. 

# Plot All Curves From tcplfit2_core
This section shows you a function that takes in output from `tcplfit2_core` and plots the concentration response data along with all the model fits. The `log_conc` argument allows users to convert the x-axis (concentration) into log-10 scale. 
For this vignette I use the first row of `signature` data set as examples. 
```{r}
# using the first row of signature as an example 
data("signatures")
conc=as.numeric(str_split(signatures[1,"conc"],"\\|")[[1]])
resp=as.numeric(str_split(signatures[1,"resp"],"\\|")[[1]])
cutoff=signatures[1,"cutoff"]

# run curve fitting
output <- tcplfit2_core(conc, resp, cutoff)

# get plots in normal and in log-10 concentration scale
basic <- plot_allcurves(output, conc, resp)
basic_log <- plot_allcurves(output, conc, resp, log_conc = T)
grid.arrange(basic, basic_log)
```

**Figure 1**: The plot generated by `plot_allcurves` displays the observed data points and all the model fits.

# Plot the Winning Curve
`concRespPlot2` generates a basic plot displaying only the observed concentration response data and the wining curve. Argument `log_conc` is also availble to convert the x-axis into log-10 scale. 
```{r}
row = list(conc=conc,
           resp=resp,
           bmed=0,
           cutoff=cutoff,
           onesd=signatures[1,"onesd"],
           name=signatures[1,"name"],
           assay=signatures[1,"signature"])

# run concentration-response modeling 
out = concRespCore(row,conthits=F)
basic_plot <- concRespPlot2(out)
basic_log <- concRespPlot2(out, log_conc = TRUE)
grid.arrange(basic_plot, basic_log)
```

**Figure 2**: The basic plot displays the observed data points, winning fitted curve, and what the winning model is.

## Customaization
In the following section I will show you have to add some common details to the basic plot generated from `concRespPlot2`. Below code shows you how to add titles to include identification information for the compound and assay, and markers for cutoff band and the estimated BMD.
```{r}
cutoff <- out[, "cutoff"]
basic_plot + 
  # Cutoff Band
  geom_rect(aes(xmin = 0,xmax = 30,ymin = -cutoff,ymax = cutoff),
            alpha = 0.1,fill = "skyblue") +
  # Titles
  ggtitle(
    label = paste("Best Model Fit",
                  out[, "name"],
                  sep = "\n"),
    subtitle = paste("Assay Endpoint: ",
                     out[, "assay"])) +
  ## Add potency estimates such as BMD
  geom_hline(
    aes(yintercept = out[, "bmr"]),
    col = "blue") +
  geom_segment(
    aes(x = out[, "bmd"], xend = out[, "bmd"], y = -0.5, yend = out[, "bmr"]),
    col = "blue"
  ) + geom_point(aes(x = out[, "bmd"], y = out[, "bmr"], fill = "BMD"), shape = 21, cex = 2.5)
```

There are more potency estimated returned in the result (e.g. AC50). The lines of `geom_hline` and `geom_segment` are re-usable to add markers for more potency estimates on the plot if desired. The following code shows you another way and less repeated way to add multiple potency estimates at a time:
```{r}
# Get all potency estimates and the corresponding y value on the curve
estimate_points <- out %>%
  select(bmd, acc, ac50, ac10, ac5) %>%
  tidyr::pivot_longer(everything(), names_to = "Potency Estimates") %>%
  mutate(`Potency Estimates` = toupper(`Potency Estimates`)) 

y = c(out[, "bmr"], out[, "cutoff"], rep(out[, "top"], 3))
y = y * c(1, 1, .5, .1, .05)
estimate_points <- cbind(estimate_points, y = y)

# add Potency Estimate Points and set colors
basic_plot + geom_point(
  data = estimate_points,
  aes(x = value, y = y, fill = `Potency Estimates`), shape = 21, cex = 2.5
)
```

## Add Another Curve
Below code chunk shows you have to add another curve for comparison. Information about the other winning curves you want to compare must be available in advance. You might use the code to plot the curve on top of the basic plot.  

```{r}
# maybe want to extract and use the same x's in the base plot 
# to calculate a smooth curve 
conc_plot <- basic_plot[["layers"]][[2]][["data"]][["conc_plot"]]

basic_plot +
  # fitted parameter values of another cueve you want to add
  geom_line(data=data.frame(x=conc_plot, y=tcplfit2::exp4(c(0.5, 10, 1.2), conc_plot)), aes(x,y,color = "exp5"))+
  # add different colors for comparisons 
  scale_colour_manual(values=c("#CC6666", "#9999CC")) +
  labs(title = "Chemical X v.s. Chemical Y")
```

## Log Scale
Be mindful that you need to log-transform the parameter values when you use log-10 x-axis.
```{r}
# add Potency Estimate Points and set colors - with plot in log-10 concentration
basic_log + geom_point(
  data = estimate_points,
  aes(x = log10(value), y = y, fill = `Potency Estimates`), shape = 21, cex = 2.5
)
```







