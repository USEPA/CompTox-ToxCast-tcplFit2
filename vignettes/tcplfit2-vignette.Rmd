---
title: "tcplfit2-vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tcplfit2-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(tcplfit2)
```
# Getting started with tcplfit2
The package tcplfit2 contains the core concentration-response functionality of the package tcpl
(The ToxCast Pipeline) built to process all of the ToxCast high-throughput screen (HTS) data at
the US EPA. Much of the rest of the code in tcpl is used to do data processing, normalization,
and database storage. We wanted to reuse the core concentration-response code for other projects,
and add extensions to it, which was the origin of the current package *tcplfit2*. The main set of extensions 
was to include all of the concentration-response models that are contained in the program BMDExpress. 
These include exponential and power functions in addition to the original Hill, gain-loss and constant models.
Additionally, we wanted to include BMD (Benchmark Dose Modeling) outputs, which is simply defining a 
Benchmark Response (BMR) level and setting the BMD to the concentration where the curve crosses the BMR level. 
One final addition was to let the hitcall value be a continuous number ranging from 0 to 1. This vignette describes 
the basic functionality of this package with two simple examples.

## Example 1 - Running a single concentration-response calculation
All calculations use the function `concRespCore` which has several key inputs. The first set are 
put into a named list called 'row':

* `conc` - a vector of concentrations (not log concentrations)
* `resp` - a vector of responses, of the same length as `conc`. Note that replicates are allowed, i.e. there can be multiple pairs of conc and resp with the same concentration value.
* `cutoff`- this is the value that the response must exceed before a a curve can be called a hit. For ToxCast, this is usually some multiple (typically 3) of the median absolute deviation (BMAD) around baseline for the lowest two concentration. The user is free to make other choices
* `bmed` - this is the median of the baseline, and will usually be set to zero. If not, the entire response series will be shifted by this amount.
* `onesd`- This is one standard deviation of the nose around the baseline. The BMR value = `onesd`*`bmr_scale`. The default `bmr_scale` is 1.349.

The list `row` can also have other optional elements which will be included in the output. These can be,
for instance, the name of the chemical (or other identifiers) or the name of the assay being modeled. Two other 
parameters might be used. The first is a Boolean `conthits`. If TRUE (the default, and recommended usage), the hitcall
returned will be a continuous value between 0 and 1. The other is `do.plot`. If this is set to TRUE (default is FALSE),
a plot of the curve will be generated. The user can also select only a subset of the models to be run. The example below has all of the possible ones
included. the model `cnst` always needs to be included. For some applications, we exclude the `gnls` model.

To run a simple example, use the following code ...
```{r example1, fig.height = 7, fig.width = 7}
  conc <- list(.03,.1,.3,1,3,10,30,100)
  resp <- list(0,.2,.1,.4,.7,.9,.6, 1.2)
  row = list(conc = conc, resp = resp, bmed = 0, cutoff = 1, onesd = .5,name="some chemical")
  res <- concRespCore(row,fitmodels = c("cnst", "hill", "gnls", "poly1", "poly2", "pow", "exp2", "exp3",
                                        "exp4", "exp5"),conthits = T, do.plot=T)
  
```

The output of this run will be a data frame with one row, summarizing the results for the winning model.

## Example 2: Running a series of concentration-response models for a single assay
The input data for this example is taken from one of the Tox21 HTS assays, for estrogen receptor (ER) 
agonist activity. The data is from the mc3 table in the database `invitrodb`, which is the back end for
*tcpl*. This example will run 6 chemicals out of the 100 that are included in the data set, and will create plots 
for these. The plotting routine `concRespPlot` is somewhat generic, and we anticipate that users will make
their own version of this. To run this example, use the following code ...

```{r example2, fig.height = 8, fig.width = 7, eval = FALSE}
  # read in the data
  file <- "data/mc3.RData"
  load(file=file)

  # set up a 3 x 2 grid for the plots
  oldpar <- par(no.readonly = TRUE)
  on.exit(par(oldpar))            
  par(mfrow=c(3,2),mar=c(4,4,2,2))

  # determine the background variation
  temp <- mc3[mc3$logc<= -2,"resp"]
  bmad <- mad(temp)
  onesd <- sd(temp)
  cutoff <- 3*bmad

  # select six samples. Note that there may be more than one sample processed for a given chemical
  spid.list <- unique(mc3$spid)
  spid.list <- spid.list[1:6]

  for(spid in spid.list) {
    # select the data for just this sample
    temp <- mc3[is.element(mc3$spid,spid),]

    # The data file has stored concentration in log10 form, so fix that
    conc <- 10**temp$logc
    resp <- temp$resp

    # pull out all of the chemical identifiers and the name of the assay
    dtxsid <- temp[1,"dtxsid"]
    casrn <- temp[1,"casrn"]
    name <- temp[1,"name"]
    assay <- temp[1,"assay"]

    # create the row object
    row <- list(conc = conc, resp = resp, bmed = 0, cutoff = cutoff, onesd = onesd,assay=assay,dtxsid=dtxsid,casrn=casrn,name=name)

    # run the concentration-response modeling for a single sample
    res <- concRespCore(row,fitmodels = c("cnst", "hill", "gnls", "poly1", "poly2", "pow", "exp2", "exp3",
                                          "exp4", "exp5"),conthits = T, aicc = F,bidirectional=F)

    # plot the results
    concRespPlot(res,ymin=-10,ymax=100)
  }


```

One would typically save the result rows in a data frame end export these for further analysis. You could remove the plotting function from the current loop and have a loop that read from the overall results data frame and only plot selected results (e.g. those with significant responses).

## Example 3: Plotting concentration-response modeling on transcriptional signatures
The input data for this example contains 6 signatures for one chemical in a transcriptomics data set.  This data set is a sample from the signature scoring method that provides the cutoff, one standard deviation, and the concentration-response data. The example illustrates two kinds of plots available in *tcplfit2*. In the call to `concRespCore()`, the argument `do.plot` is set to `TRUE`, which provides a simple plot showing results of all the different curve fitting methods. Next, utilizing the function `concRespPlot()` provides a more informative plot for the winning model.
```{r example3, fig.height = 6, fig.width = 7}
  # call additional R packages
  library(stringr)  # string management package

  # read in the file
  data("signatures")
  
  # set up a 3 x 2 grid for the plots
  oldpar <- par(no.readonly = TRUE)
  on.exit(par(oldpar))            
  par(mfrow=c(3,2),mar=c(4,4,2,2))
    
  # fit 6 observations in signatures
  for(i in 1:nrow(signatures)){
    # set up input data
    row = list(conc=as.numeric(str_split(signatures[i,"conc"],"\\|")[[1]]),
               resp=as.numeric(str_split(signatures[i,"resp"],"\\|")[[1]]),
               bmed=0,
               cutoff=signatures[i,"cutoff"],
               onesd=signatures[i,"onesd"],
               name=signatures[i,"name"],
               assay=signatures[i,"signature"])
    # run concentration-response modeling (1st plotting option)
    out = concRespCore(row,conthits=F,do.plot=T)
    if(i==1){
      res <- out
    }else{
      res <- rbind.data.frame(res,out)
    }
  }
```

```{r example3_plot2, fig.height = 8, fig.width = 7}
  # set up a 3 x 2 grid for the plots
  oldpar <- par(no.readonly = TRUE)
  on.exit(par(oldpar))            
  par(mfrow=c(3,2),mar=c(4,4,2,2))
  # plot results using `concRespPlot`(2nd plotting option)
  for(i in 1:nrow(res)){
    concRespPlot(res[i,],ymin=-1,ymax=1)
  }
```

## Example 4: Running tcplfit2 on standalone tcpl-like data from mc0.

The input for this example is from ACEA data that has been released in past versions of invitrodb. Those familiar with the data format in tcpl will recognize the data in the format of multiconcentration level 0 data otherwise known as mc0.  Data from the assay component ACEA_AR_agonist_80hr was analyzed in the positive analysis fitting direction relative to DMSO as the negative control and baseline of activity. Using a type of growth reporter, measures of the cells for gain-of-signal activity can be used to understand the signaling at the pathway-level as they relate to the gene AR.

```{r example4_init, fig.height = 6, fig.width = 7}

load(file = "../data/mc0.rda")
library(tcpl)
library(data.table)
dat <- mc0
DT::datatable(head(dat),options = list(scrollX = T))
```

The above table is identical to the mc0 table that would be seen in tcpl.  However, some users may want to run standalone tcplfit2 fitting without the need for a database connection.  The first steps (levels 1 through 3 in tcpl) are used to adjust the data and determine the noise levels that will later be used for cutoff calcualtion.
```{r example4_mc2, fig.height = 6, fig.width = 7}
#In this case there are no adjustments required for the data so we set cval to the original rval
dat[,cval := rval]
## Fitting generally cannot occur if response values are NA or null so we remove them
dat <- dat[!is.na(cval),]
## Add column for log10 concentration as some of the mc3 methods require logc
dat[ , logc := log10(conc)]

# ## Initialize the bval, pval, and resp columns
# dat[ , c('bval', 'pval', 'resp') := NA_real_]

## initialize dummy aeid required if using mc3_mthds from tcpl
dummy_aeid <- 99999
dat[,aeid := dummy_aeid]

## Set aeid as a key
setkey(dat,aeid)
```

Once the data is initialized to a point where the required fields are available we can use the methods included in the tcpl package without the need for a database connection.  You can see the list of available methods for mc3 in the table below.

```{r example4_mthdlist, fig.height = 6, fig.width = 7}
mthd_funcs <- tcpl:::mc3_mthds()
DT::datatable(tcpl::tcplMthdList(3),options = list(scrollX = T))
```

The following 3 methods are selected from the list above and are applied to the data.  Note because of the way tcpl handles the application of functions, the dataframe must be called `dat`.  In the future tcpl will export these functions so that they can be applied to any dataset without the need for a specific name or dummy aeid.

```{r example4_mc3methods, fig.height = 6, fig.width = 7, results = 'hide'}
# apply level 3 methods
lapply(mthd_funcs[["bval.apid.nwlls.med"]](dummy_aeid), eval)
lapply(mthd_funcs[["pval.apid.medncbyconc.min"]](dummy_aeid),eval)
lapply(mthd_funcs[["resp.pc"]](dummy_aeid),eval)
```

The next step is to calculate the concentration index.  The concentration index is simply the distinct concentrations ranked from lowest to highest.  Generally this index is used to calculate the baseline median absolute deviation for an assay.

```{r example4_cndx, fig.height = 6, fig.width = 7}

#calculate cndx (concentration index)
# this code can be simplified
## Define replicate id
# Order by the following columns
setkeyv(dat, c('acid', 'srcf', 'apid', 'coli', 'rowi', 'spid', 'conc'))
# Define rpid column for test compound wells
nconc <- dat[wllt == "t" ,
             list(n = lu(conc)),
             by = list(acid, apid, spid)][ , list(nconc = min(n)), by = acid]
dat[wllt == "t" & acid %in% nconc[nconc > 1, acid],
    rpid := paste(acid, spid, wllt, srcf, apid, "rep1", conc, sep = "_")]
dat[wllt == "t" & acid %in% nconc[nconc == 1, acid],
    rpid := paste(acid, spid, wllt, srcf, "rep1", conc, sep = "_")]
# Define rpid column for non-test compound wells
dat[wllt != "t",
    rpid := paste(acid, spid, wllt, srcf, apid, "rep1", conc, sep = "_")]

# set repid based on rowid
dat[, dat_rpid := rowid(rpid)]
dat[, rpid := sub("_rep[0-9]+.*", "",rpid, useBytes = TRUE)]
dat[, rpid := paste0(rpid,"_rep",dat_rpid)]

## Define concentration index
indexfunc <- function(x) as.integer(rank(unique(x))[match(x, unique(x))])
dat[ , cndx := indexfunc(conc), by = list(rpid)]
```

Once the concentration index has been calculated, the level 4 methods can be loaded in a similar way to level 3.

```{r example4_mthdlist_l4, fig.height = 6, fig.width = 7}
mthd_funcs_l4 <- tcpl:::mc4_mthds()
DT::datatable(tcpl::tcplMthdList(4),options = list(scrollX = T))
```

There are much fewer level 4 methods, but generally it is a requirement to have a method that calculates the bmad and a method that calculates the standard deviation of the noise.

```{r example4_mc4methods, fig.height = 6, fig.width = 7, results = 'hide'}
# apply level 4 methods
lapply(mthd_funcs_l4[["bmad.aeid.lowconc.twells"]](),eval)
lapply(mthd_funcs_l4[["onesd.aeid.lowconc.twells"]](),eval)
lapply(mthd_funcs_l4[["bidirectional.false"]](),eval)

```

After all methods up to level 4 have been applied, the model fitting steps can begin.  In tcpl this would be considered level 4, and is where `tcplfit2` is used to fit all of the models.


```{r example4_fitting, fig.height = 6, fig.width = 7}

#do tcplfit2 fitting

myfun <- function(y) {
  res <- tcplfit2::tcplfit2_core(y$conc,
                          y$resp,
                          cutoff = unique(y$bmad),
                          bidirectional = TRUE,
                          verbose = FALSE,
                          force.fit = TRUE,
                          fitmodels = c("cnst", "hill", "gnls", "poly1",
                                        "poly2", "pow", "exp2", "exp3",
                                        "exp4", "exp5")
                          )
  list(list(res)) #use list twice because data.table uses list(.) to look for values to assign to columns
}


# only want to run tcplfit2 for test wells in this case
dat[wllt == 't',params:= myfun(.SD), by = .(spid)]
```


After all of the models have been fit, hitcalling can occur.  The output of level 4 can be fed directly into the `tcplhit2_core` function.  The results are then pivoted and shown in the resulting datatable.

```{r example4_hitcalling, fig.height = 6, fig.width = 7}

myfun2 <- function(y) {
  res <- tcplfit2::tcplhit2_core(params = y$params[[1]],
                                 conc = y$conc,
                                 resp = y$resp,
                                 cutoff = 3*unique(y$bmad),
                                 onesd = unique(y$osd)
                                 )
  list(list(res))
}

# continute with hitcalling
res <- dat[wllt == 't', myfun2(.SD), by = .(spid)]

#pivot wider
res_wide <- rbindlist(Map(cbind, spid = res$spid, res$V1))

DT::datatable(res_wide,options = list(scrollX = T))

```
